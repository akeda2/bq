# jq -- job queue

`jq` is a very simple program that maintains a queue of one job.  Unlike
[exqueue](http://github.com/sitaramc/exqueue), which has a "server" component
managing the queue and firing off tasks as each one completes, `jq` simply
uses a database and locking to manage the queue.

(You will need to install the `DBM::Deep` perl module for `jq` to work).

Here's the usage message.

    Usage: jq [-status|-t|-f|-c|-e|-purge]
           jq [-s time] command [args]

    -status: if no arguments are supplied, '-status' is implied
    -t: "tail" running and queued jobs' stdout and stderr files
    -f: print and "flush" completed jobs stdout and stderr files
    -c: show "completed" jobs
    -e: show jobs with "errors"

    -purge: purge everything (assuming no jobs are running and no outputs pending
        flush)

    -s: time is an integer, followed optionally by 's', 'm', or 'h' (no spaces).
        The job will first sleep for that duration and *then* get queued.

It's mostly self-explanatory, or at least I hope it is.

# notes

1.  When you do something like this:

        jq wget -c --progress=dot:mega http://media.risky.biz/RB391.mp3
        jq id3v2 -D RB391.mp3

    `jq` does not check if the wget finished OK or not; as far as it is
    concerned these are two separate jobs.  If you need conditional
    evaluation, you need to run them together, like `jq 'command1 &&
    command2'`.

2.  The `-s time` is useful when you want to run a job after some delay.  You
    might think this should work:

        jq sleep 2h
        jq wget ...

    But that sleep is now holding up the queue needlessly -- you can't run
    anything else until that is done.  Instead, this:

        jq -s 2h wget ...

    sleeps before doing anything at all, so the queue is not held up, letting
    you continue to use it in the meanwhile.  In fact, until the 2 hours (in
    this example) have passed, you won't even see the job in the status
    output; you can only see it using `ps` or some variant (like `pgrep`).

# TODO

queue jumping, canceling a queued job, setting the number of jobs that can be
running at any time, redoing the last failed job, ...
